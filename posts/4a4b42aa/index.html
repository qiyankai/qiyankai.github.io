<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>HashMap知识梳理 - 老K的博客</title><meta description="一文读懂HashMap本文准备从以下几个方面去讲解HashMap：1）HashMap源码详细分析2）HashMap为什么是线程不安全的？3）1.7和1.8的HashMap实现区别总结4）HashMap和HashTable的区别 HashMap源码分析一、构造函数让我们先从构造函数说起，HashMap有四个构造方法，别慌 1.1 HashMap()&amp;#x2F;&amp;#x2F; 1.无参构造方法、 &amp;#x2F;&amp;#x2F; 构造一个空的Hash"><meta property="og:type" content="article"><meta property="og:title" content="HashMap知识梳理"><meta property="og:url" content="https://qiyankai.github.io/posts/4a4b42aa/"><meta property="og:site_name" content="老K"><meta property="og:description" content="一文读懂HashMap本文准备从以下几个方面去讲解HashMap：1）HashMap源码详细分析2）HashMap为什么是线程不安全的？3）1.7和1.8的HashMap实现区别总结4）HashMap和HashTable的区别 HashMap源码分析一、构造函数让我们先从构造函数说起，HashMap有四个构造方法，别慌 1.1 HashMap()&amp;#x2F;&amp;#x2F; 1.无参构造方法、 &amp;#x2F;&amp;#x2F; 构造一个空的Hash"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-10-10T14:02:05.000Z"><meta property="article:modified_time" content="2020-05-14T01:18:13.273Z"><meta property="article:author" content="qiyankai"><meta property="article:tag" content="Java HashMap"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://qiyankai.github.io/img/yazi.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://qiyankai.github.io/posts/4a4b42aa/"},"headline":"HashMap知识梳理","image":["https://qiyankai.github.io/img/yazi.png"],"datePublished":"2019-10-10T14:02:05.000Z","dateModified":"2020-05-14T01:18:13.273Z","author":{"@type":"Person","name":"qiyankai"},"description":"一文读懂HashMap本文准备从以下几个方面去讲解HashMap：1）HashMap源码详细分析2）HashMap为什么是线程不安全的？3）1.7和1.8的HashMap实现区别总结4）HashMap和HashTable的区别 HashMap源码分析一、构造函数让我们先从构造函数说起，HashMap有四个构造方法，别慌 1.1 HashMap()&#x2F;&#x2F; 1.无参构造方法、 &#x2F;&#x2F; 构造一个空的Hash"}</script><link rel="alternative" href="/atom.xml" title="老K的博客" type="application/atom+xml"><link rel="icon" href="/img/yazi.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/yazi.png" alt="老K的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/tags/%E6%B3%95%E5%BE%8B/">律法</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">瞎说</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/qiyankai"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-10T14:02:05.000Z">2019-10-10</time><a class="commentCountImg" href="/posts/4a4b42aa/#comment-container"><span class="display-none-class">ecaaf3b520d986661382eb760ac676f5</span><img class="not-gallery-item" src="/img/chat.svg"> <span class="commentCount" id="ecaaf3b520d986661382eb760ac676f5"> 99+</span>    </a><span class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/HashMap/">HashMap</a></span><span class="level-item">39 分钟 读完 (大约 5871 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">HashMap知识梳理</h1><div class="content"><h1 id="一文读懂HashMap"><a href="#一文读懂HashMap" class="headerlink" title="一文读懂HashMap"></a>一文读懂HashMap</h1><p>本文准备从以下几个方面去讲解HashMap：<br>1）HashMap源码详细分析<br>2）HashMap为什么是线程不安全的？<br>3）1.7和1.8的HashMap实现区别总结<br>4）HashMap和HashTable的区别</p>
<h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h3><p>让我们先从构造函数说起，HashMap有四个构造方法，别慌</p>
<h4 id="1-1-HashMap"><a href="#1-1-HashMap" class="headerlink" title="1.1 HashMap()"></a>1.1 HashMap()</h4><pre><code>// 1.无参构造方法、
// 构造一个空的HashMap，初始容量为16，负载因子为0.75
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}</code></pre><a id="more"></a>

<p>无参构造方法就没什么好说的了。</p>
<h4 id="1-2-HashMap-int-initialCapacity"><a href="#1-2-HashMap-int-initialCapacity" class="headerlink" title="1.2 HashMap(int initialCapacity)"></a>1.2 HashMap(int initialCapacity)</h4><pre><code>// 2.构造一个初始容量为initialCapacity，负载因子为0.75的空的HashMap，
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}</code></pre><p>HashMap(int initialCapacity) 这个构造方法调用了1.3中的构造方法。</p>
<h4 id="1-3-HashMap-int-initialCapacity-float-loadFactor"><a href="#1-3-HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="1.3 HashMap(int initialCapacity, float loadFactor)"></a>1.3 HashMap(int initialCapacity, float loadFactor)</h4><pre><code>// 3.构造一个空的初始容量为initialCapacity，负载因子为loadFactor的HashMap
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                           initialCapacity);
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}

//最大容量
//static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></pre><p>当指定的初始容量&lt; 0时抛出IllegalArgumentException异常，当指定的初始容量&gt; MAXIMUM_CAPACITY时，就让初始容量 = MAXIMUM_CAPACITY。当负载因子小于0或者不是数字时，抛出IllegalArgumentException异常。</p>
<p>设定threshold。 这个threshold = capacity * load factor 。当HashMap的size到了threshold时，就要进行resize，也就是扩容。</p>
<p>tableSizeFor()的主要功能是返回一个比给定整数大且最接近的2的幂次方整数，如给定10，返回2的4次方16.</p>
<p>我们进入tableSizeFor(int cap)的源码中看看：</p>
<pre><code>//Returns a power of two size for the given target capacity.
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}</code></pre><p>note： HashMap要求容量必须是2的幂。</p>
<p>首先，int n = cap -1是为了防止cap已经是2的幂时，执行完后面的几条无符号右移操作之后，返回的capacity是这个cap的2倍，因为cap已经是2的幂了，就已经满足条件了。 如果不懂可以往下看完几个无符号移位后再回来看。（建议自己在纸上画一下）</p>
<p>如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是1（最后有个n+1的操作）。这里只讨论n不等于0的情况。<br>以16位为例，假设开始时 n 为 0000 1xxx xxxx xxxx （x代表不关心0还是1）</p>
<p>第一次右移 n |= n &gt;&gt;&gt; 1;</p>
<p>由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如0000 11xx xxxx xxxx 。</p>
<p>第二次右移 n |= n &gt;&gt;&gt; 2;</p>
<p>注意，这个n已经经过了n |= n &gt;&gt;&gt; 1; 操作。此时n为0000 11xx xxxx xxxx ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如0000 1111 xxxx xxxx 。</p>
<p>第三次右移 n |= n &gt;&gt;&gt; 4;</p>
<p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中会有8个连续的1。如0000 1111 1111 xxxx 。</p>
<p>第。。。，你还忍心让我继续推么？相信聪明的你已经想出来了，容量最大也就是32位的正数，所以最后一次 n |= n &gt;&gt;&gt; 16; 可以保证最高位后面的全部置为1。当然如果是32个1的话，此时超出了MAXIMUM_CAPACITY ，所以取值到 MAXIMUM_CAPACITY 。</p>
<p>从<a href="https://blog.csdn.net/huzhigenlaohu/article/details/51802457这篇博客中找了张示例图：">https://blog.csdn.net/huzhigenlaohu/article/details/51802457这篇博客中找了张示例图：</a></p>
<p>tableSizeFor示例图</p>
<p><img src="https://img-blog.csdnimg.cn/20200513171136653.png#pic_center" alt="在这里插入图片描述"><br>注意，得到的这个capacity却被赋值给了threshold。 这里我和这篇博客的博主开始的想法一样，认为应该这么写：this.threshold = tableSizeFor(initialCapacity) * this.loadFactor; 因为这样子才符合threshold的定义：threshold = capacity * load factor 。但是，请注意，在构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算 。</p>
<p>我说一下我在理解这个tableSizeFor函数中间遇到的坑吧，我在想如果n=-1时的情况，因为初始容量可以传进来0。我将n= -1 和下面几条运算一起新写了个测试程序，发现输出都是 -1。 这是因为计算机中数字是由补码存储的，-1的补码是 0xffffffff。所以无符号右移之后再进行或运算之后还是 -1。 那我想如果就无符号右移呢？ 比如-1&gt;&gt;&gt;10。听我娓娓道来，32个1无符号右移10位后，高10位为0，低22位为1，此时这个数变成了正数，由于正数的补码和原码相同，所以就变成了0x3FFFFF即10进制的4194303。真刺激。</p>
<p>好开森，这个构造方法我们算是拿下了。怎么样，我猜你现在一定很激动，Hey，old Fe，这才刚开始。接下来看最后一个构造方法。</p>
<h4 id="1-4-HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#1-4-HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="1.4 HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>1.4 HashMap(Map&lt;? extends K, ? extends V&gt; m)</h4><pre><code>// 4. 构造一个和指定Map有相同mappings的HashMap，初始容量能充足的容下指定的Map,负载因子为0.75
public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}</code></pre><p>套路，直接看 putMapEntries(m,false) 。源码如下：</p>
<pre><code>/**
 * 将m的所有元素存入本HashMap实例中
 */
final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
    //得到 m 中元素的个数
    int s = m.size();
    //当 m 中有元素时，则需将map中元素放入本HashMap实例。
    if (s &gt; 0) {
        // 判断table是否已经初始化，如果未初始化，则先初始化一些变量。（table初始化是在put时）
        if (table == null) { // pre-size
            // 根据待插入的map 的 size 计算要创建的　HashMap 的容量。
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);
            // 把要创建的　HashMap 的容量存在　threshold　中
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        }
        // 如果table初始化过，因为别的函数也会调用它，所以有可能HashMap已经被初始化过了。
        // 判断待插入的　map 的 size,若　size 大于　threshold，则先进行　resize()，进行扩容
        else if (s &gt; threshold)
            resize();
        //然后就开始遍历 带插入的 map ，将每一个 &lt;Key ,Value&gt; 插入到本HashMap实例。
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            // put(K,V)也是调用　putVal　函数进行元素的插入
            putVal(hash(key), key, value, false, evict);
        }
    }
}</code></pre><p>介绍putVal方法前，说一下HashMap的几个重要的成员变量：</p>
<pre><code>/**
 * The table, initialized on first use, and resized as
 * necessary. When allocated, length is always a power of two.
 * (We also tolerate length zero in some operations to allow
 * bootstrapping mechanics that are currently not needed.)
 */
//实际存储key，value的数组，只不过key，value被封装成Node了
transient Node&lt;K,V&gt;[] table;

/**
 * The number of key-value mappings contained in this map.
 */
transient int size;

/**
 * The number of times this HashMap has been structurally modified
 * Structural modifications are those that change the number of mappings in
 * the HashMap or otherwise modify its internal structure (e.g.,
 * rehash).  This field is used to make iterators on Collection-views of
 * the HashMap fail-fast.  (See ConcurrentModificationException).
 */
transient int modCount;

/**
 * The next size value at which to resize (capacity * load factor).
 *
 * @serial
 */
// (The javadoc description is true upon serialization.
// Additionally, if the table array has not been allocated, this
// field holds the initial array capacity, or zero signifying
// DEFAULT_INITIAL_CAPACITY.)
//因为 tableSizeFor(int) 返回值给了threshold
int threshold;

/**
 * The load factor for the hash table.
 *
 * @serial
 */
final float loadFactor;</code></pre><p>其实就是哈希表。HashMap使用链表法避免哈希冲突（相同hash值），当链表长度大于TREEIFY_THRESHOLD（默认为8）时，将链表转换为红黑树，当然小于UNTREEIFY_THRESHOLD（默认为6）时，又会转回链表以达到性能均衡。 我们看一张HashMap的数据结构（数组+链表+红黑树 ）就更能理解table了：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513171319423.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>再回到putMapEntries函数中，如果table为null，那么这时就设置合适的threshold，如果不为空并且指定的map的size&gt;threshold，那么就resize()。然后把指定的map的所有Key，Value，通过putVal添加到我们创建的新的map中。</p>
<p>putVal中传入了个hash(key)，那我们就先来看看hash(key):</p>
<p>/**<br>     * key 的 hash值的计算是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)<br>     * 主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候<br>     * 也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销<br>     */<br>    static final int hash(Object key) {<br>        int h;<br>        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>    }</p>
<p>异或运算：(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p>
<p>原 来 的 hashCode : 1111 1111 1111 1111 0100 1100 0000 1010<br>移位后的hashCode: 0000 0000 0000 0000 1111 1111 1111 1111<br>进行异或运算 结果：1111 1111 1111 1111 1011 0011 1111 0101</p>
<p>这样做的好处是，可以将hashcode高位和低位的值进行混合做异或运算，而且混合后，低位的信息中加入了高位的信息，这样高位的信息被变相的保留了下来。掺杂的元素多了，那么生成的hash值的随机性会增大。</p>
<p>刚才我们漏掉了resize()和putVal() 两个函数，现在我们按顺序分析一波：</p>
<p>首先resize() ,先看一下哪些函数调用了resize()，从而在整体上有个概念：</p>
<p><img src="https://img-blog.csdnimg.cn/2020051317152724.png#pic_center" alt="在这里插入图片描述"></p>
<p>接下来上源码：</p>
<pre><code>final Node&lt;K,V&gt;[] resize() {
    // 保存当前table
    Node&lt;K,V&gt;[] oldTab = table;
    // 保存当前table的容量
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    // 保存当前阈值
    int oldThr = threshold;
    // 初始化新的table容量和阈值 
    int newCap, newThr = 0;
    /*
    1. resize（）函数在size　&gt; threshold时被调用。oldCap大于 0 代表原来的 table 表非空，
       oldCap 为原表的大小，oldThr（threshold） 为 oldCap × load_factor
    */
    if (oldCap &gt; 0) {
        // 若旧table容量已超过最大容量，更新阈值为Integer.MAX_VALUE（最大整形值），这样以后就不会自动扩容了。
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
         // 容量翻倍，使用左移，效率更高
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            // 阈值翻倍
            newThr = oldThr &lt;&lt; 1; // double threshold
    }
    /*
    2. resize（）函数在table为空被调用。oldCap 小于等于 0 且 oldThr 大于0，代表用户创建了一个 HashMap，但是使用的构造函数为      
       HashMap(int initialCapacity, float loadFactor) 或 HashMap(int initialCapacity)
       或 HashMap(Map&lt;? extends K, ? extends V&gt; m)，导致 oldTab 为 null，oldCap 为0， oldThr 为用户指定的 HashMap的初始容量。
　　*/
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        //当table没初始化时，threshold持有初始容量。还记得threshold = tableSizeFor(t)么;
        newCap = oldThr;
    /*
    3. resize（）函数在table为空被调用。oldCap 小于等于 0 且 oldThr 等于0，用户调用 HashMap()构造函数创建的　HashMap，所有值均采用默认值，oldTab（Table）表为空，oldCap为0，oldThr等于0，
    */
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 新阈值为0
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
    // 初始化table
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 把 oldTab 中的节点　reHash 到　newTab 中去
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                // 若节点是单个节点，直接在 newTab　中进行重定位
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                // 若节点是　TreeNode 节点，要进行 红黑树的 rehash　操作
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                // 若是链表，进行链表的 rehash　操作
                else { // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    // 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割（代码后有图解，可以回过头再来看），分成两个不同的链表，完成rehash
                    do {
                        next = e.next;
                        // 根据算法　e.hash &amp; oldCap 判断节点位置rehash　后是否发生改变
                        //最高位==0，这是索引不变的链表。
                        if ((e.hash &amp; oldCap) == 0) { 
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        //最高位==1 （这是索引发生改变的链表）
                        else {  
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {  // 原bucket位置的尾指针不为空(即还有node)  
                        loTail.next = null; // 链表最后得有个null
                        newTab[j] = loHead; // 链表头指针放在新桶的相同下标(j)处
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        // rehash　后节点新的位置一定为原来基础上加上　oldCap，具体解释看下图
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}</code></pre><p>}</p>
<p>引自美团点评技术博客。我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513171554106.png#pic_center" alt="hashMap 1.8 哈希算法例图1.png"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513171607711.png#pic_center" alt="hashMap 1.8 哈希算法例图2.png"></p>
<p>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513171657295.png#pic_center" alt="在这里插入图片描述"></p>
<p>什么时候扩容：通过HashMap源码可以看到是在put操作时，即向容器中添加元素时，判断当前容器中元素的个数是否达到阈值（当前数组长度乘以加载因子的值）的时候，就要自动扩容了。</p>
<p>扩容(resize)：其实就是重新计算容量；而这个扩容是计算出所需容器的大小之后重新定义一个新的容器，将原来容器中的元素放入其中。</p>
<p>resize()告一段落，接下来看 putVal() 。</p>
<p>上源码：</p>
<pre><code>//实现put和相关方法。
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    //如果table为空或者长度为0，则resize()
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //确定插入table的位置，算法是(n - 1) &amp; hash，在n为2的幂时，相当于取摸操作。
    ////找到key值对应的槽并且是第一个，直接加入
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    //在table的i位置发生碰撞，有两种情况，1、key值是一样的，替换value值，
    //2、key值不一样的有两种处理方式：2.1、存储在i位置的链表；2.2、存储在红黑树中
    else {
        Node&lt;K,V&gt; e; K k;
        //第一个node的hash值即为要加入元素的hash
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        //2.2
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        //2.1
        else {
            //不是TreeNode,即为链表,遍历链表
            for (int binCount = 0; ; ++binCount) {
            ///链表的尾端也没有找到key值相同的节点，则生成一个新的Node,
            //并且判断链表的节点个数是不是到达转换成红黑树的上界达到，则转换成红黑树。
                if ((e = p.next) == null) {
                     // 创建链表节点并插入尾部
                    p.next = newNode(hash, key, value, null);
                    ////超过了链表的设置长度8就转换成红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        //如果e不为空就替换旧的oldValue值
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}</code></pre><p>注：hash 冲突发生的几种情况：<br>1.两节点key 值相同（hash值一定相同），导致冲突；<br>2.两节点key 值不同，由于 hash 函数的局限性导致hash 值相同，冲突；<br>3.两节点key 值不同，hash 值不同，但 hash 值对数组长度取模后相同，冲突；</p>
<p>相比put方法，get方法就比较简单，这里就不说了。</p>
<h2 id="1-7和1-8的HashMap的不同点"><a href="#1-7和1-8的HashMap的不同点" class="headerlink" title="1.7和1.8的HashMap的不同点"></a>1.7和1.8的HashMap的不同点</h2><p>（1）JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法就是能够提高插入的效率，但是也会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</p>
<p>（2）扩容后数据存储位置的计算方式也不一样：</p>
<p>在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1） 。<br>而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。<br>（3）JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（N）变成O（logN）提高了效率）。</p>
<p>HashMap为什么是线程不安全的？<br>HashMap 在并发时可能出现的问题主要是两方面：</p>
<p>put的时候导致的多线程数据不一致<br>比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。<br>resize而引起死循环<br>这种情况发生在HashMap自动扩容时，当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。</p>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>
<p>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。<br>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。<br>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<br>HashMap不能保证随着时间的推移Map中的元素次序是不变的。<br>需要注意的重要术语：</p>
<p>sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。</p>
<p>Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p>
<p>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p>
<p>HashMap可以通过下面的语句进行同步：<br>Map m = Collections.synchronizeMap(hashMap);</p>
<p>参考资料<br><a href="https://tech.meituan.com/java_hashmap.html">https://tech.meituan.com/java_hashmap.html</a></p>
</div><div class="article-tags size-small is-uppercase mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><p class="text-right font1_1"><time datetime="2020-05-14T01:18:13.273Z"><strong><em> 本文最后修改于: 2020-05-14.</em></strong></time></p></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://qiyankai.github.io/posts/4a4b42aa/">HashMap知识梳理</a></li><li><strong>本文作者：</strong><a href="https://qiyankai.github.io">老K</a></li><li><strong>本文链接：</strong><a href="https://qiyankai.github.io/posts/4a4b42aa/">https://qiyankai.github.io/posts/4a4b42aa/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/posts/1a54ada2/" target="_blank">博客源码分享</a><br></span><span>  2.<a class="is-size-6" href="/posts/47c45f64/" target="_blank">博客中gitalk最新评论的获取</a><br></span><span>  3.<a class="is-size-6" href="/posts/a49f841a/" target="_blank">中华人民共和国刑事诉讼法</a><br></span><span>  4.<a class="is-size-6" href="/posts/4a17b156/" target="_blank">Hello World</a><br></span><span>  5.<a class="is-size-6" href="/posts/e7fe3cc/" target="_blank">github Issue 作为博客微型数据库的应用</a><br></span></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/b22caa49/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">synchronized知识梳理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/89986481/"><span class="level-item">不蒜子统计常见问题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script src="/js/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: 'ecaaf3b520d986661382eb760ac676f5',
            repo: 'qiyankai.github.io',
            owner: 'qiyankai',
            clientID: '1520b1a1d9db8b3e4535',
            clientSecret: '4994a7a2ff4e6421db6554f762cf75750c0ee98e',
            admin: ["qiyankai"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" id="toc-item-一文读懂HashMap" href="#一文读懂HashMap"><span>一文读懂HashMap</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-HashMap源码分析" href="#HashMap源码分析"><span>HashMap源码分析</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-4-HashMap-Map-lt-extends-K-extends-V-gt-m" href="#1-4-HashMap-Map-lt-extends-K-extends-V-gt-m"><span>1.4 HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m)</span></a></li><li><a class="is-flex" id="toc-item-HashMap的数据结构" href="#HashMap的数据结构"><span>HashMap的数据结构</span></a></li></ul></li><li><a class="is-flex" id="toc-item-1-7和1-8的HashMap的不同点" href="#1-7和1-8的HashMap的不同点"><span>1.7和1.8的HashMap的不同点</span></a></li><li><a class="is-flex" id="toc-item-HashMap和HashTable的区别" href="#HashMap和HashTable的区别"><span>HashMap和HashTable的区别</span></a></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/yazi.png" alt="老K"></figure><p class="title is-size-4 is-block line-height-inherit">老K</p><p class="is-size-6 is-block">🕺 🕺 🕺🏻⚰️🕺 🕺 🕺🏻  🕺</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/qiyankai" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/qiyankai"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Weibo" href="/"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1694577129@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Next" href="https://qiyankai.github.io"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟延迟...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/posts/4a17b156/"><p class="image is-64x64"><img class="thumbnail" src="https://qiyankai.github.io/img/hello.jpg" alt="Hello World"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-14T13:18:38.000Z">2020-04-14</time></p><p class="title is-6"><a class="link-muted" href="/posts/4a17b156/">Hello World</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-11-28T14:02:05.000Z">2019-11-28</time></p><p class="title is-6"><a class="link-muted" href="/posts/b22caa49/">synchronized知识梳理</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Java/">Java</a> / <a class="link-muted" href="/categories/Java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-10-10T14:02:05.000Z">2019-10-10</time></p><p class="title is-6"><a class="link-muted" href="/posts/4a4b42aa/">HashMap知识梳理</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Java/">Java</a> / <a class="link-muted" href="/categories/Java/HashMap/">HashMap</a></p></div></article><article class="media"><a class="media-left" href="/posts/89986481/"><p class="image is-64x64"><img class="thumbnail" src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191221090606.png" alt="不蒜子统计常见问题"></p></a><div class="media-content size-small"><p><time dateTime="2018-12-21T00:46:08.000Z">2018-12-21</time></p><p class="title is-6"><a class="link-muted" href="/posts/89986481/">不蒜子统计常见问题</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/">工具教程</a> / <a class="link-muted" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/">博客统计插件</a></p></div></article><article class="media"><a class="media-left" href="/posts/e7fe3cc/"><p class="image is-64x64"><img class="thumbnail" src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191128220618.png" alt="github Issue 作为博客微型数据库的应用"></p></a><div class="media-content size-small"><p><time dateTime="2018-11-28T14:02:05.000Z">2018-11-28</time></p><p class="title is-6"><a class="link-muted" href="/posts/e7fe3cc/">github Issue 作为博客微型数据库的应用</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/">工具教程</a> / <a class="link-muted" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/">主题工具</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java/HashMap/"><span class="level-start"><span class="level-item">HashMap</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">线程安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/private/"><span class="level-start"><span class="level-item">private</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">工具教程</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">主题工具</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"><span class="level-start"><span class="level-item">博客统计插件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%B3%95%E5%BE%8B/"><span class="level-start"><span class="level-item">法律</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%95%E5%BE%8B/"><span class="tag">法律</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"><span class="tag">工具教程</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo%E4%B8%BB%E9%A2%98/"><span class="tag">hexo主题</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"><span class="tag">icarus主题配置</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF/"><span class="tag">技术</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"><span class="tag">加密文章</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"><span class="tag">博客统计插件</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=removeifFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="removeifFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">输入邮箱开始订阅，更博后邮件通知！</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/yazi.png" alt="老K的博客" height="28"></a><p class="size-small"><span>&copy; 2020 老K</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif" target="_blank">removeif</a> <br>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br>    方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br><script type="text/javascript" src="/js/statistics.js"></script><span id="statistic-times">网站运行时间统计加载中...</span><br><div class="size-small"><span id="busuanzi_container_site_uv">❤️感谢<strong> <span id="busuanzi_value_site_uv">99+</span> </strong></span>小伙伴的<strong> <span id="busuanzi_value_site_pv">99+</span> </strong>次光临，点击查看本博客主题，感谢removeif大佬开源💐<a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">主题源码</a>！❤️</div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/qiyankai"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://qiyankai.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/comment-issue-data.js" defer></script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>